use salvo::prelude::*;
use web_common::jwt::UserClaim;
use serde_json::json;
use deadpool_redis::Pool;
use redis::AsyncCommands;

use web_common::{
    bail,
    core::{
        resp::R,
        constant::cache::token2key,
        utils,
    },
};
use web_common::core::constant::cache::id2key;
use crate::domain::user::User;

/// 用户注册处理函数
#[handler]
pub async fn register(req: &mut Request, res: &mut Response) -> R {
    // 从请求体中提取用户数据
    let mut register_user = match req.extract::<User>().await {
        Ok(user) => user,
        Err(e) => return R::fail(format!("Invalid user data: {}", e)),
    };
    
    // 检查用户名是否已存在
    let user = User::select_by_name(&register_user.username).await.unwrap();

    if user.is_some() {
        bail!("username exists");
    }

    // 加密密码
    register_user.password = utils::password::encode(&register_user.password);

    // 插入新用户
    User::insert(&register_user).await.unwrap();

    R::no_val_success()
}

/// 用户登录处理函数
#[handler]
pub async fn login(req: &mut Request, depot: &mut Depot) -> R {
    // 从请求体中提取登录数据
    let login_user = match req.extract::<User>().await {
        Ok(user) => user,
        Err(e) => return R::fail(format!("Invalid login data: {}", e)),
    };
    
    // 获取Redis连接池
    let redis_pool = match depot.obtain::<Pool>() {
        Some(pool) => pool,
        None => return R::err("Redis pool not available"),
    };
    
    // 查询用户
    let user = User::select_by_name(&login_user.username).await.unwrap();

    let user = match user {
        Some(user) => user,
        None => bail!("user not exists")
    };

    // 验证密码
    if !utils::password::verify(&user.password, &login_user.password) {
        bail!("password error");
    }

    // 创建JWT令牌
    let user_claim = UserClaim::new();
    let token = UserClaim::sign(user_claim);

    // 将用户信息存储到Redis，用于后续认证
    let mut conn = match redis_pool.get().await {
        Ok(conn) => conn,
        Err(e) => return R::err(format!("Failed to get Redis connection: {}", e)),
    };
    
    if let Err(e) = conn.set_ex(token2key(&token), user, 3600).await {
        return R::err(format!("Failed to store token in Redis: {}", e));
    }

    R::success(json!({ "token": token }))
}

/// 检查用户认证状态处理函数
#[handler]
pub async fn check(depot: &mut Depot) -> R {
    // 从depot中获取用户信息（由认证中间件放入）
    let user = match depot.obtain::<User>() {
        Some(user) => user,
        None => return R::fail("User not authenticated"),
    };
    
    R::success(json!({ "user": user }))
}

/// 创建认证路由
pub fn routes() -> Router {
    Router::with_path("auth")
        .post("/register", register)
        .post("/login", login)
        .push(
            Router::with_path("check")
                .hoop(auth_middleware())
                .get(check)
        )
}

/// 创建认证中间件
fn auth_middleware() -> impl Handler {
    |req: &mut Request, depot: &mut Depot, res: &mut Response, ctrl: &mut FlowCtrl| async move {
        // 从请求头或查询参数中提取token
        let token = req.headers()
            .get("Authorization")
            .and_then(|auth| auth.to_str().ok())
            .and_then(|auth| auth.strip_prefix("Bearer "))
            .map(|token| token.to_string())
            .or_else(|| {
                req.uri().query()
                    .and_then(|query| {
                        query.split('&')
                            .filter_map(|s| s.strip_prefix("Authorization=Bearer%20"))
                            .map(|s| s.to_string())
                            .last()
                    })
            });
        
        if let Some(token) = token {
            // 获取Redis连接池
            if let Some(redis_pool) = depot.obtain::<Pool>() {
                // 从Redis获取用户信息
                if let Ok(mut conn) = redis_pool.get().await {
                    if let Ok(Some(user)) = conn.get::<_, Option<User>>(token2key(&token)).await {
                        // 将用户信息存入depot
                        depot.insert(user);
                        return;
                    }
                }
            }
        }
        
        // 认证失败，返回401状态码
        res.status_code(StatusCode::UNAUTHORIZED);
        ctrl.skip_rest();
    }
}